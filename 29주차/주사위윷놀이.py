# 다음 위치를 가리치는 인덱스를 배열. 10, 20, 30 이 적힌 칸일 경우에는 2가지 
# 방향으로 뻗을 수 있기 때문에 배열의 길이가 2이며 [빨간 방향, 파란방향]을 의미.
# 도착칸, 시작칸 모두 0이고 도착칸이 가리키는 다음 위치는 자기 자신.
next = [[1], [2], [3], [4], [5],
         [6, 21], [7], [8], [9], [10],
         [11, 25], [12], [13], [14], [15],
         [16, 27], [17], [18], [19], [20],
         [32], [22], [23], [24], [30],
         [26], [24], [28], [29], [24],
         [31], [20], [32]]
# 점수칸을 담은 배열 0 2개는 각각 시작칸과 도착칸. 각 해당 칸의 점수가 가리키는 다음 위치 인덱스를
# 위의 next가 담고 있다.
score = [0, 2, 4, 6, 8,
         10, 12, 14, 16, 18,
         20, 22, 24, 26, 28,
         30, 32, 34, 36, 38,
         40, 13, 16, 19, 25,
         22, 24, 28, 27, 26,
         30, 35, 0]

dice = list(map(int,input().split()))

answer = 0

def dfs(L,total,horse):
    global answer
    if L >= 10: # 10번 턴. 10번 턴 이전에 모든 말이 도착할 수 없기 때문에, 점수 갱신은 마지막에 가능.
        answer = max(answer,total)
        return
    for i in range(4): # 4개의 말 중에서
        if horse[i] != 32: # 아직 도착X 칸 이라면,
            x = horse[i] # 현재 위치를 담는다
            if len(next[x]) == 2: # 가리키는 위치가 2개라면 파란칸이므로, 파란 화살표 방향선택.
                x = next[x][1]
            else:
                x = next[x][0] # 빨간칸이므로, 빨간 화살표 방향선택.
            for _ in range(1,dice[L]): # 앞에서 이미 한 칸 이동했기에, 1부터 dice[L]번 이동.
                x = next[x][0] # 도착했을 때의 칸을 가리킨다.
            
            # 이동 후에 도착칸 또는 이전 칸이고 다른 말이 해당 칸에 없다면 이동한다.
            if x == 32 or (x < 32 and x not in horse): 
                prev = horse[i] # 이전 말의 위치를 담는다.
                horse[i] = x # 말의 위치 갱신
                dfs(L+1,total+score[x], horse)
                horse[i] = prev # 백트래킹.

dfs(0,0,[0,0,0,0])
print(answer)