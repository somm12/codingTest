g = []
n = int(input())
dx = [0,1,0,-1]
dy = [-1,0,1,0]
for _ in range(n):
    g.append(list(map(int,input().split())))
# 좌 하 우 상 방향으로 이동하며, 각 방향마다 모래가 흩어지는 위치 와 비율을 담은 3차원 배열.
arr = [[(-1,0,7),(1,0,7),(-1,-1,10),(1,-1,10),(-1,1,1),(1,1,1),(-2,0,2),(2,0,2),(0,-2,5)],
[(-1,-1,1),(-1,1,1),(0,-1,7),(0,1,7),(1,-1,10),(1,1,10),(0,-2,2), (0,2,2),(2,0,5)],
[(-1,0,7),(1,0,7),(-1,1,10),(1,1,10),(-1,-1,1),(1,-1,1),(-2,0,2),(2,0,2),(0,2,5)],
[(-1,-1,10),(-1,1,10),(0,-1,7),(0,1,7),(1,-1,1),(1,1,1),(-2,0,5),(0,-2,2),(0,2,2)]]
def go():
    cnt = 0 # 몇 칸 씩 움질일 것인지.
    d = 0 # 현재 이동하는 방향.
    total = 0 # 범위에 벗어난 총 모래양(구하고자 하는 답)
    tx,ty = n//2, n//2 # 처음 가운데 위치.
    while True:
        d = d%4 # 0,1,2,3 반복을 위함.
        if d % 2 ==0: # 1칸, 1칸 ,2칸, 2칸, 3,3 .. 등 2개씩 점점 움직이는 칸수가 +1 늘어남.
            cnt += 1
        for _ in range(cnt): 
            tx += dx[d] # 이도가 한 칸 움직임.
            ty += dy[d]
            if tx == 0 and ty == -1: # 혹시 마지막인 0,0에서 이동을 마치게 된다면 종료.
                return total
            
            remain = g[tx][ty] # 현재 토네이도가 이동한 방향의 모래양. 흩어지고 남은 양을 기억.
            for x,y,p in arr[d]: # 흩어지는 위치(x,y)와 해당 위치로 갈 비율 p.
                nx = tx+x
                ny = ty+y
                cal = int(g[tx][ty]*(p/100)) # 비율 계산
                
                if 0 <= nx < n and 0 <= ny < n: # 범위 내로 흩어진다면 비율만큼 더해짐.
                    g[nx][ny] += cal
                    remain -= cal # 흩어진 양만큼 남은 모래양 감소.
                else:               #범위 밖으로 흩어진다면
                    remain -= cal# *** 똑같이 모래양 감소
                    total += cal # 구하고자하는 바깥으로 흩어진 모래양 더한다.
            # ***** 
            a = tx + dx[d] # 비율만큰 흩어지게 하고, 그 다음 칸인 알파칸에 남은 모래양을 전달.
            b = ty + dy[d]
            if 0 <= a < n and 0 <= b < n: # 범위 내라면, 더해주고
                g[a][b] += remain# ***
            else:                       # 아니면 벗어난 만큼 더해줌.
                total += remain
            g[tx][ty] = 0 # 원래위치는 이제 0
            # *****
        
        d += 1 # 방향 증가 : 좌, 하, 우, 상  반복.
        

print(go())